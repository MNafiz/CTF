

# This file was *autogenerated* from the file main.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2582928974243465355371953056699793745022552378548418288211138499777818633265 = Integer(2582928974243465355371953056699793745022552378548418288211138499777818633265); _sage_const_2421683573446497972507172385881793260176370025964652384676141384239699096612 = Integer(2421683573446497972507172385881793260176370025964652384676141384239699096612); _sage_const_4368590184733545720227961182704359358435747188309319510520316493183539079703 = Integer(4368590184733545720227961182704359358435747188309319510520316493183539079703); _sage_const_8742397231329873984594235438374590234800923467289367269837473862487362482 = Integer(8742397231329873984594235438374590234800923467289367269837473862487362482); _sage_const_225987949353410341392975247044711665782695329311463646299187580326445253608 = Integer(225987949353410341392975247044711665782695329311463646299187580326445253608); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_3115846653938504361650386437377404449680779872497727646346367670719915515442 = Integer(3115846653938504361650386437377404449680779872497727646346367670719915515442); _sage_const_2810666857764293539402767964015657133595357252060455687347132657823581321982 = Integer(2810666857764293539402767964015657133595357252060455687347132657823581321982); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
from collections import namedtuple
from Crypto.Util.number import inverse, bytes_to_long, long_to_bytes
from sage.all import *

qx=_sage_const_2582928974243465355371953056699793745022552378548418288211138499777818633265 
qy=_sage_const_2421683573446497972507172385881793260176370025964652384676141384239699096612 

p = _sage_const_4368590184733545720227961182704359358435747188309319510520316493183539079703 
gx = _sage_const_8742397231329873984594235438374590234800923467289367269837473862487362482 
gy = _sage_const_225987949353410341392975247044711665782695329311463646299187580326445253608 
a = (qy ** _sage_const_2  - gy ** _sage_const_2  - qx ** _sage_const_3  + gx ** _sage_const_3 ) * inverse((qx - gx) % p, p) % p
b = (gy ** _sage_const_2  - gx ** _sage_const_3  - a * gx) % p
F = GF(p)
A = F['x, y']; (x, y,) = A._first_ngens(2)
print(F['x'](x**_sage_const_3 +a*x+b).factor())
c1 = _sage_const_3115846653938504361650386437377404449680779872497727646346367670719915515442 
c2 = _sage_const_2810666857764293539402767964015657133595357252060455687347132657823581321982 
c = (c1 - c2) % p
print("c =", c)
# Create a simple Point class to represent the affine points.
Point = namedtuple("Point", "x y")

# The point at infinity (origin for the group law).
O = 'Origin'


def check_point(P):
    if P == O:
        return True
    else:
        return (P.y**_sage_const_2  - (P.x**_sage_const_3  + a*P.x + b)) % p == _sage_const_0  and _sage_const_0  <= P.x < p and _sage_const_0  <= P.y < p


def point_inverse(P):
    if P == O:
        return P
    return Point(P.x, -P.y % p)


def point_addition(P, Q):
    if P == O:
        return Q
    elif Q == O:
        return P
    elif Q == point_inverse(P):
        return O
    else:
        if P == Q:
            lam = (_sage_const_3 *P.x**_sage_const_2  + a)*inverse(_sage_const_2 *P.y, p)
            lam %= p
        else:
            lam = (Q.y - P.y) * inverse((Q.x - P.x), p)
            lam %= p
    Rx = (lam**_sage_const_2  - P.x - Q.x) % p
    Ry = (lam*(P.x - Rx) - P.y) % p
    R = Point(Rx, Ry)
    assert check_point(R)
    return R


def double_and_add(P, n):
    Q = P
    R = O
    while n > _sage_const_0 :
        if n % _sage_const_2  == _sage_const_1 :
            R = point_addition(R, Q)
        Q = point_addition(Q, Q)
        n = n // _sage_const_2 
    assert check_point(R)
    return R


G = Point(gx, gy)
Q = Point(x=_sage_const_2582928974243465355371953056699793745022552378548418288211138499777818633265 , y=_sage_const_2421683573446497972507172385881793260176370025964652384676141384239699096612 )
# f = x^3 + a*x + b
# _f = f.sub(x=x + c2)
P = GF(p)['x']; (x,) = P._first_ngens(1)
f = x**_sage_const_3  + a*x + b
f_ = f.subs(x=x - c2)
Q_ = (Q.x + c2, Q.y)
G_ = (G.x + c2, G.y)
print(f_.factor())
t = GF(p)(c).square_root()
v = (Q_[_sage_const_1 ] + t*Q_[_sage_const_0 ])/(Q_[_sage_const_1 ] - t*Q_[_sage_const_0 ]) % p
u = (G_[_sage_const_1 ] + t*G_[_sage_const_0 ])/(G_[_sage_const_1 ] - t*G_[_sage_const_0 ]) % p
d = discrete_log(v, u)
print(long_to_bytes(d))

