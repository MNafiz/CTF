

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_115792089237316195423570985008687907853269984665640564039457584007908834671663 = Integer(115792089237316195423570985008687907853269984665640564039457584007908834671663); _sage_const_7 = Integer(7); _sage_const_3 = Integer(3); _sage_const_64 = Integer(64); _sage_const_10 = Integer(10); _sage_const_10903 = Integer(10903); _sage_const_5290657 = Integer(5290657); _sage_const_14 = Integer(14); _sage_const_109903 = Integer(109903); _sage_const_383229727 = Integer(383229727); _sage_const_16 = Integer(16); _sage_const_3319 = Integer(3319); _sage_const_22639 = Integer(22639); _sage_const_32 = Integer(32); _sage_const_199 = Integer(199); _sage_const_18979 = Integer(18979)
from pwn import *
from sage.all import *
from Crypto.Util.number import *
from sympy import sqrt_mod, gcd

NC = "nc 178.128.102.145 50002".split()

r = remote(NC[_sage_const_1 ], NC[_sage_const_2 ])
r.recvuntil(b"Encrypted flag: ")
enc_flag = bytes.fromhex(r.recvline(_sage_const_0 ).decode())

p = _sage_const_115792089237316195423570985008687907853269984665640564039457584007908834671663 
a = _sage_const_0  
b = _sage_const_7 

def goto(n):
    r.sendlineafter(b"> ", str(n).encode())

def gen_key():
    goto(_sage_const_1 )
    r.recvuntil(b"Private key: ")
    priv_key_user = r.recvline(_sage_const_0 )
    r.recvuntil(b"Public key: ")
    pub_key_user = r.recvline(_sage_const_0 )
    return priv_key_user, pub_key_user


priv_key_user, pub_key_user = gen_key()

def encrypt(pub):
    goto(_sage_const_2 )
    r.sendlineafter(b"key: ", pub)
    r.sendlineafter(b": ", b"61")
    r.recvuntil(b"Shared ephemeral secret: ")
    return bytes.fromhex(r.recvline(_sage_const_0 ).decode())

def decompress(x, b):
    bit = int(x[_sage_const_0 ])
    x = bytes_to_long(x[_sage_const_1 :])
    y = sqrt_mod(x**int(_sage_const_3 ) + int(b), int(p))
    if y == None:
        return None, None
    if Mod(y, _sage_const_2 ) != Mod(bit, _sage_const_2 ):
        y = p - y
    return x, y

def compress(x, y):
    bit = y % _sage_const_2 
    if bit == _sage_const_1 :
        result = "03" + hex(x)[_sage_const_2 :].zfill(_sage_const_64 )
    else:
        result = "02" + hex(x)[_sage_const_2 :].zfill(_sage_const_64 )
    return result.encode()

import math
bb = {
    _sage_const_10  : [_sage_const_10903 , _sage_const_5290657 ],
    _sage_const_14  : [_sage_const_109903 ,  _sage_const_383229727 ], #383229727 12977017
    _sage_const_16  : [_sage_const_3319 , _sage_const_22639 ],
    # 27 : [10833080827],
    _sage_const_32  : [_sage_const_199 , _sage_const_18979 ]
}


import math
perk = _sage_const_1 
for b in bb:
    perk *= math.prod(bb[b])

print(int(perk).bit_length())


Ebase = EllipticCurve(GF(p), [a, _sage_const_7 ])
print(Ebase.order())

dlogs = []
faks = []

for b in bb:
    E = EllipticCurve(GF(p), [a, b])
    G = E.gen(_sage_const_0 )
    order = E.order()
    for fak in bb[b]:
        point_small_order = G * (order // fak)
        x_mal, y_mal = list(point_small_order)[:-_sage_const_1 ]
        pub = "04" + hex(x_mal)[_sage_const_2 :].zfill(_sage_const_64 ) + hex(y_mal)[_sage_const_2 :].zfill(_sage_const_64 )
        hasil = encrypt(pub.encode())
        x, y = decompress(hasil, b)
        scalar_mult_point_small_order = E(x, y)
        log = point_small_order.discrete_log(scalar_mult_point_small_order)
        dlogs.append(log)
        faks.append(fak)
        print(log)


d = CRT_list(dlogs, faks)
print(hex(d)[_sage_const_2 :])
print(enc_flag.hex())
print(int(d).bit_length())

goto(_sage_const_3 )
r.sendlineafter(b": ", hex(d)[_sage_const_2 :].encode())
r.sendlineafter(b": ", enc_flag.hex().encode())
r.recvuntil(b"Decrypted message: ")

flag = bytes.fromhex(r.recvline(_sage_const_0 ).decode())

print(flag)

#CJ2023{real_world_crypto_3b8786f9}
r.interactive()

